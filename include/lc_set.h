/////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2012, Jared Duke.
// This code is released under the MIT License.
// www.opensource.org/licenses/mit-license.php
/////////////////////////////////////////////////////////////////////////////

#ifndef _LC_SET_H_
#define _LC_SET_H_

#include "lc_common.h"
#include "lc_utils.h"

#include <iterator>

namespace lc {


// A utility container for generating list comprehensions
//    Stores the following:
//      1) The source lists
//      2) A set of filters for tuples generated by the cartesian product of the source lists
//      3) A transform* that maps candidate tuples to output values
//           The default transform simply yields the filtered tuple
template< typename R, typename... Args >
struct cartesian {

  typedef std::tuple<typename types<Args>::list...>                 tuple_list;
  typedef std::tuple<typename types<Args>::list::iterator...>       tuple_iter;
  typedef std::tuple<typename types<Args>::list::const_iterator...> const_tuple_iter;
  typedef typename gens<sizeof...(Args)>::type                      tuple_indices;
  typedef decltype(tuple_apply(tuple_indices(), tuple_iter(),  deref())) tuple_value;

  typedef std::function<bool(Args...)>      filter_type;
  typedef typename types<filter_type>::list filter_list;

  typedef std::function<R(Args...)> transform_type;
  typedef typename types<R>::list   result_list;

  template< typename > class iterator;
  template< typename > friend class iterator;
  template< typename,typename... > friend class cartesian;

  ///////////////////////////////////////////////////////////////////////////
  // Constructors

  // Construct from lists of types Args...
  cartesian(typename types<Args>::list... args)
    : mLists(std::make_tuple(std::move(args)...)),
      mTransform(std::make_tuple<Args...>) { }

  // Construct from lists of types Args..., and a list of filters
  cartesian(typename types<Args>::list... args, std::initializer_list<filter_type> l)
    : mLists(std::make_tuple(std::move(args)...)),
      mFilters(std::move(l)),
      mTransform(std::make_tuple<Args...>) { }

  // Copy constructor
  //  TODO: Disable this
  cartesian(const cartesian& other)
    : mLists(other.mLists),
      mFilters(other.mFilters),
      mTransform(other.mTransform) { }

  // Copy move constructor
  cartesian(cartesian&& other) {
    swap(std::move(other));
  }

  // Copy constructor from set with different transform type
  //  TODO: Disable this
  template<typename R2>
  cartesian(const cartesian<R2,Args...>& other)
    : mLists(other.mLists),
      mFilters(other.mFilters) { }

  // Copy move constructor from set with different transform type
  template<typename R2>
  cartesian(cartesian<R2,Args...>&& other) {
    std::swap(mLists,   other.mLists);
    std::swap(mFilters, other.mFilters);
  }

  // Assignment operator
  cartesian& operator=(cartesian&& other) {
    swap(std::move(other));
  }


  ///////////////////////////////////////////////////////////////////////////
  // Methods


  // Adds a filter to the set, no processing is performed
  //    The filter must have a signature of type:   bool(Args...)
  template< typename F >
  cartesian& where(F f) {
    mFilters.push_back(filter_type(f));
    return *this;
  }

  // Adds a list of filters to the set, no processing is performed
  //    Each filter must have a signature of type:  bool(Args...)
  template< typename F >
  cartesian& where(std::initializer_list<F> fs) {
    std::copy(std::begin(fs), std::end(fs), std::back_inserter(mFilters));
    return *this;
  }

  // Sets the transform for the set, no processing is performed
  //    The transform must have a signature of type: R(Args...)
  template< typename F >
  cartesian& select(F f) {
    mTransform = transform_type(f);
    return *this;
  }

  // Return the set formed by the cartesian product of the associated lists, where
  //    1) Each candidate tuple from the source lists satisfies all filter conditions and
  //    2) Each set element is the result of transforming the candidate tuple by the member transform
  result_list operator()() const {
    result_list results;
    auto back = back_inserter(results);

    for (auto b = tupleBegin(), it = tupleBegin(), e = tupleEnd(); iterate(it, b, e); )
      if( filter(it) )
        back = transform(it);

    return results;
  }

  // Return an iterator to the first element of the output set
  //   Note: Set generation is lazy.  Filtering and transforming is only performed
  //         as the iterator is incremented and dereferenced.
  iterator<const_tuple_iter> begin() const { return iterator<const_tuple_iter>(tupleBegin(), *this); }

  // Return an iterator to the end of the output set
  //   Note: This does not refer to a valid value, and should not be dereferenced
  iterator<const_tuple_iter> end()   const { return iterator<const_tuple_iter>(tupleEnd(),   *this); }

private:

  cartesian();
  cartesian& operator=(const cartesian&);

  void swap(cartesian&& other) {
    std::swap(mLists,     other.mLists);
    std::swap(mFilters,   other.mFilters);
    std::swap(mTransform, other.mTransform);
  }

  // Create a tuple of values from a tuple of iterators
  static tuple_value valueOf(tuple_iter it) {
    return tuple_apply(tuple_indices(), it,     deref());
  }

  // Create a tuple of values from a tuple of const iterators
  static tuple_value valueOf(const_tuple_iter it) {
    return tuple_apply(tuple_indices(), it,     deref());
  }

  // Create a tuple of iterators to the beginnings of each list in a tuple of lists
  tuple_iter tupleBegin() {
    return tuple_apply(tuple_indices(), mLists, container_begin());
  }

  // Create a tuple of const iterators to the beginnings of each list in a tuple of lists
  const_tuple_iter tupleBegin() const {
    return tuple_apply(tuple_indices(), mLists, container_begin());
  }

  // Create a tuple of iterators to the ends of each list in a tuple of lists
  tuple_iter tupleEnd() {
    return tuple_apply(tuple_indices(), mLists, container_end());
  }

  // Create a tuple of const iterators to the ends of each list in a tuple of lists
  const_tuple_iter tupleEnd() const {
    return tuple_apply(tuple_indices(), mLists, container_end());
  }

  // Return whether the value referenced by the iterator satisifes all filter conditions
  bool filter(tuple_iter& it) const {
    const auto v = valueOf(it);
    for (auto f = std::begin(mFilters); f != std::end(mFilters); ++f) {
      if (!apply(tuple_indices(), v, *f))
        return false;
    }
    return true;
  }

  // Return whether the value referenced by the const iterator satisifes all filter conditions
  bool filter(const_tuple_iter& it) const {
    const auto v = valueOf(it);
    for (auto f = std::begin(mFilters); f != std::end(mFilters); ++f) {
      if (!apply(tuple_indices(), v, *f))
        return false;
    }
    return true;
  }

  // Transform the value referenced by the iterator according to the member transform
  R transform(tuple_iter it) const {
    return apply(tuple_indices(), valueOf(it), mTransform);
  }

  // Transform the value referenced by the const iterator according to the member transform
  R transform(const_tuple_iter it) const {
    return apply(tuple_indices(), valueOf(it), mTransform);
  }

  ///////////////////////////////////////////////////////////////////////////

  tuple_list     mLists;     // A tuple containing the user-provided lists of data
  filter_list    mFilters;   // A list of filters for the candidate tuples
  transform_type mTransform; // A transform that maps filtered tuples to the output set

};

// An iterator to the set that yields filtered and transformed set elements
//    List filtering is performed as the iterator is incremented
//    List transforming is performed only when the iterator is dereferenced
template< typename R, typename... Args>
template< typename It >
class cartesian<R,Args...>::iterator : public std::iterator<std::forward_iterator_tag, R, ptrdiff_t, const R*, const R&> {
public:

  iterator(It it, cartesian& c)
    : mIt(it), mBegin(c.tupleBegin()), mEnd(c.tupleEnd()), mDirty(true), mSource(c) { advanceBegin(); }

  iterator(It it, const cartesian& c)
    : mIt(it), mBegin(c.tupleBegin()), mEnd(c.tupleEnd()), mDirty(true), mSource(c) { advanceBegin(); }

  iterator(const iterator& other)
    : mIt(other.mIt), mBegin(other.mBegin), mEnd(other.mEnd), mDirty(other.mDirty), mSource(other.mSource) { }

  const R& operator*()  const { update();  return  mValue; }
  const R* operator->() const { update();  return &mValue; }
  iterator& operator++()      { advance(); return *this;   }

  bool operator==(const iterator& other) { return mIt == other.mIt; }
  bool operator!=(const iterator& other) { return mIt != other.mIt; }
  operator bool() const { return mIt != mEnd; }

private:

  void update() const {
    if (!mDirty)
      return;

    mValue = mSource.transform(mIt);
    mDirty = false;
  }

  void advance(size_t count = 1) {
    mDirty = count > 0;
    while (count > 0 && iterate(mIt, mBegin, mEnd)) {
      if(mSource.filter(mIt))
        --count;
    }
  }

  void advanceBegin() {
    if(!mSource.filter(mIt))
      advance();
  }

  It  mIt;
  It  mBegin;
  It  mEnd;
  mutable R   mValue;
  mutable bool     mDirty;
  const cartesian& mSource;
};

///////////////////////////////////////////////////////////////////////////
// Set creation
//
// from(x,y,z) creates a cartesian set from the lists x,y and z


// Create a cartesian set from the specified vectors, not necessarily of the same underlying type
template<typename... Args>
cartesian<std::tuple<Args...>, Args...> from(const std::vector<Args>&... args) {
  return cartesian<std::tuple<Args...>, Args...>(args...);
}

// Create a cartesian set from the specified movable vectors, not necessarily of the same underlying type
template<typename... Args>
cartesian<std::tuple<Args...>, Args...> from(typename types<Args>::list&&... args) {
  return cartesian<std::tuple<Args...>, Args...>(std::move(args)...);
}

// Create a cartesian set from the specified arrays, not necessarily of the same underlying type
template< size_t... Sizes, typename... Args>
cartesian<std::tuple<Args...>, Args...> from(const std::array<Args,Sizes>&... args) {
  return cartesian<std::tuple<Args...>, Args...>(toList(args)...);
}

// Create a cartesian set from the specified containers, not necessarily of the same underlying type
//    Each container must have valid usage with std::begin() and std::end()
template< template<typename T> class C, typename... Args>
cartesian<std::tuple<Args...>, Args...> from(C<Args>... args) {
  return cartesian<std::tuple<Args...>, Args...>(toList(args)...);
}

///////////////////////////////////////////////////////////////////////////

} // namespace lc

#endif // _LC_SET_H_
